# Turbo exec manual

Once you imported that package and enabled all the scripts, you can request turbo from any script by doing the following :
```
executesync("TE2.2:start")
; What you want your script to do
executesync("TE2.2:stop")
wait(0.0) ; This is a no-op, because "executesync("TE2.2:stop")" must never be on the last line
```

It's important for multiple reasons that you use `executesync` and not just `execute` here (more is explained in the source codes of the various scripts.

If your script runs in a loop, you can do this :
```
loopstart:
executesync("TE2.2:start")
; What you want your script to do
executesync("TE2.2:stop")
gotoif(loopstart, should_keep_running)
```
You don't need an extra no-op in this case, as long as the `should_keep_running` condition will stay false at the end.

And if you want to ensure that your action runs in its entierty in a single frame :
```
:global int turbo.cycles.max
:global int turbo.cycles

loopstart:
executesync("TE2.2:start")
turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + number_higher_then_the_number_of_cycles_your_script_will_take)
; What you want your script to do
executesync("TE2.2:stop")
gotoif(loopstart, should_keep_running)
```
There's an extra cycle of turbo after `TE2.2:stop`, so the `gotoif` will run in the last cycle of turbo and only one frame will be used for the whole body of the loop.

It's OK to specify more cycles than your script takes, because turbo will only run for as long as scripts are requesting it.
However, it's a good idea to not be excessive, because this might prevent you from finding unexpected issues.

If you need compatibility with TEv2.1, you can also manipulate the underlying
variables directly, but this has some large caveats:
```
:global int turbo.register

loopstart:
turbo.register += 1
; If another script is using turbo, and it has already begun the turbo-stop
; process, turbo could stop somewhere in here unexpectedly before starting the
; next frame.
turbo.register -= 1
; Without an executesync, there is nothing synchronizing on the end-of-frame.
; End-of-frame *will* still occur, but at a time that is less predictable,
; unless you include additional code that basically duplicates what TE2.2:stop
; does.
gotoif(loopstart, should_keep_running)
```

To import the code into the editor, use the following import. This is only for
people wanting to make changes to turbo exec itself, for using it in-game use
the bundle import in the [README](/common/turbo_exec/README.md).
```
{"workspaces":{"TE2.2":[["turbo_2.2_start","\n:name TE2.2:start\n\n; This script registers a script for turbo exec, and exits as soon it confirms\n; turbo exec is running.\n; When executing this script, it is highly advised to execute it using\n; `execute(sync)` as among other things, this guarantees that the cycle counter\n; has started and that it is safe to overwrite `turbo.cycles.max` with a new\n; maximum value.\n\n\n; This variable is used to track how many scripts are using turbo exec.\n; It's incremented each time `TE2.2:start` is called, and decremented\n; every time `TE2.2:stop` is called. When it reaches 0, turbo is stopped\n; and waits for the next script to register.\n:global int turbo.register\n\n; This variable is used to recieve state information from `<turbo>:register`.\n:global string turbo.state\n\nturbo.register += 1 ; Increment the registry counter\n\n; This should guarantee turbo exec is up and is gonna keep running until\n; the next call to `TE2.2:stop` (assuming no script interferes or causes\n; undefined behavior).\n; For instance, if `TE2.2:start` is called shortly before cycles.max is\n; reached (due to another script using turbo), without this check it would\n; return just as turbo is stopping.\n; `goto` is being used here to stay consistent with `TE2.2:stop`.\nwait:\ngoto(if(contains(turbo.state, \"running\"), end, wait))\n\n; Finishing the script with a noop is important, else the script will get\n; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\n"],["turbo_2.2_stop","\n:name TE2.2:stop\n\n; This script unregisters a script for turbo exec, signaling that the caller\n; script wishes to resume normal execution now, thus, this script only exits\n; once it confirms that turbo isn't running anymore.\n; When executing this script, it is highly advised to execute it using\n; `execute(sync)`. This is especially important if you are gonna start turbo\n; again soon after, as this guarantees that a frame skip does happen and thus\n; prevents infinite loops, and, if you care about it, this\n; guarantees frame continuity as long as you call `TE2.2:start` again within\n; the next 2 instructions after this script returns.\n\n\n; This variable is used to track how many scripts are using turbo exec.\n; It's incremented each time `TE2.2:start` is called, and decremented\n; everytime `TE2.2:stop` is called. When it reaches 0, turbo is stopped\n; and waits for the next script to register.\n:global int turbo.register\n\n; This variable is used to recieve state information from `<turbo>:register`.\n:global string turbo.state\n\n; Decrement the registry counter. There intentionally isn't a check for\n; negative, because if the calls are unbalanced that behavior should be\n; exposed quickly so it can be found and fixed.\nturbo.register -= 1\n\n; `turbo.state` first goes through the state \"stopping\", which happens 1 cycle\n; early. By exiting one cycle early, the caller script has a 1 cycle buffer to\n; call `turbo start` again to preserve frame continuity, but since the frame\n; skip is already planned at that point, even if the caller calls `turbo start`\n; right after this exits, the frame will be skipped correctly. This allows more\n; versatility in the caller's syntax and can save some crucial lines.\n; It is important to use `goto` here instead of `waituntil`, otherwise the extra\n; cycle would be consumed by waiting for the extra noop instruction at the end.\nwait:\ngoto(if(contains(turbo.state, \"running\"), wait, end))\n\n; Finishing the script with a noop is important, else the script will get\n; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\n"],["turbo_register","\n:name TE2.2:register\n\n; This script is the main manager script, it runs the main turbo loop when\n; needed and sends state information to other scripts.\n\n\n; This variable is used to track how many scripts are using turbo exec,\n; it's incremented each time `TE2.2:start` is called, and decremented\n; everytime `TE2.2:stop` is called. When it reaches 0, turbo is stopped\n; and waits for the next script to register.\n:global int turbo.register\n\n; This variable is used to communicate state with other scripts in turbo,\n; there are 4 states possible :\n; \"stopping\" means turbo should stop on the next cycle, this state is used to\n;     allow a 1-cycle delay on when `TE2.2:start` needs to be called to\n;     guarantee that one and only one frame passed from the last `TE2.2:stop`.\n; \"active\" means that this cycle is a \"breaking\" cycle, and forces advancing\n;     to the next frame. The name is chosen because this is what will usually\n;     appear in the variable display when turbo is active.\n; \"idle\" means that turbo is idle and waiting for the next script to register\n; \"running\" means that turbo is currently running. Note that this state will\n;     never show in the variable display!\n:global string turbo.state\n\n; This variable counts the number of cycles since the beginning of the frame,\n; although it does have a delay of a few cycles, this doesn't matter for its\n; 2 main applications, which are :\n; - making sure turbo doesn't run for too long\n; - allowing scripts to calculate how many cycles passed between 2 instructions\n:global int turbo.cycles\n; This variable determines how many cycles turbo is allowed to run for at most\n; on this frame. It is reset each frame. If your script needs turbo to run for\n; longer then 200 cycles per frame, you need to set that using this variable.\n; To prevent conflicts with other scripts, please make sure to use the\n; following instruction to require more cycles :\n;\n; turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + cycles_you_require)\n;\n; The reason we add the current number of cycles to the required cycles is\n; that turbo exec might have already been running for a while due to another\n; script requiring it. If that is the case, we want to make sure we extend\n; `turbo.cycles.max` enough to run all the computation and actions we still\n; need to do.\n;\n; There is also a hard-coded limit of 50000 cycles to prevent the game from\n; freezing in case a script messed up.\n:global int turbo.cycles.max\n\nwakeup()\n\nturbo.register = 0\n\n; Kill TE2.1 scripts if they're present, to avoid compatibility issues.\n; TE2.2 and TE2.1 are identical, aside from TE2.2 being in a package, so\n; the v2.2 version can handle all the logic.\n; Wait one cycle (by setting `turbo.register` first) to avoid script-ordering\n; issues; this guarantees that the other scripts have already started, if they\n; are present. The stops must also be ordered this way to always work correctly.\nstop(\"TE2.1 register\")\nstop(\"TE2.1\")\n\nturbo.state = \"idle\"\nturbo.cycles.max = 200\nwait:\nwaituntil(turbo.register > 0) ; Wait for a script to register\nskipwait:\nexecute(\"TE2.2:counting\");\n\nturbo.state = \"running\"\n\n; Reset cycles.max to its default value at the start of each frame, even if a\n; script fails to call `TE2.2:stop` in time, it's better to reset this value\n; as the script is already in undefined behavior territory and it's preferable\n; to not hold back other scripts because of a defective script.\n; Because this is set right after `turbo.state`, even if a script tries to\n; overwrite this right after calling `TE2.2:start`, this won't cause a race\n; condition (assuming `TE2.2:start` was executed using `execute(sync)`).\nturbo.cycles.max = 200\n\n; Wait for conditions to end the frame.\n; This is written oddly, with \"min\" instead of \"||\", because \"||\" is actually\n; a trinary function and thus slower to execute. Every bit counts here in\n; the hottest cycle of turbo.\nwaituntil(0 >= min(turbo.register, min(turbo.cycles.max, 50000) - turbo.cycles))\n\n; This doesn't look like much, but this is the most crucial part of this\n; script, by signaling scripts 2 cycle earlier, and going through 4 different\n; states, we enable the groundwork for a lot of QOL features and optimizations.\n; The reason we need to buffer for 2 cycles is that one of the cycles is used up\n; when `execsync(\"TE2.2:stop\")` ends.\n\nturbo.state = \"stopping\" ; About to change to the next frame\nwait(0.0)                ; Buffered instructions\nturbo.state = \"active\"   ; Changing to the next frame on this cycle\nturbo.state = \"idle\"     ; Idle state, waiting for registration\n\n; Save a cycle if registration already happened\ngoto(if(turbo.register > 0, skipwait, wait))\n"],["turbo","\n:name TE2.2:turbo\n\n; This script combined with `TE2.2:active` forms the core of turbo exec v2.\n; Be careful: If it remains in \"turbo\" mode without ever changing state,\n; the game is gonna freeze and then crash.\n\n; The number of scripts using turbo exec.\n:global int turbo.register\n\n; This variable is used to recieve state information from `<turbo>:register`\n:global string turbo.state\n\nwakeup()\n\n; To function, this operates closely coupled with `TE2.2:active`, which has a\n; single instruction: execute(\"TE2.2:turbo\")\n;\n; To understand how this functions, first understand that there are exactly\n; two states that the scripts can be in after a cycle: Either\n; 1) `TE2.2:turbo` is about to run line #2, and `TE2.2:active` isn't running.\n; 2) `TE2.2:active` is about to run line #1, and `TE2.2:turbo` isn't running.\n;\n; Every cycle, `TE2.2:active` runs its action, either because it was already\n; running or because it is executed by `TE2.2:turbo` on line #2. This launches\n; a new copy of `TE2.2:turbo`, and the new state is completely determined by\n; the \"if\" condition on line #1.\n;\n; If the \"if\" is true, `TE2.2:turbo` is stopped, which causes \"turbo exec\" behaviour\n; because a script is stopping itself: The current script pointer is reset to\n; the beginning, effectively giving a \"free\" cycle to all scripts before it in\n; the script list. The turbo exec bug/feature also prevents scripts at the end\n; from exiting, so `TE2.2:active` will remain on line #1.\n;\n; If the \"if\" is false, `TE2.2:active` is stopped, and `TE2.2:turbo` will\n; execute line #2 next frame. This is \"regular execution mode.\"\n;\n; A side-effect of the way this works is that `TE2.2:turbo` is the only script that\n; will be running at the end of a frame, so it is the only one that will ever\n; be visible in the scripts list.\n;\n; The \"contains\" is an optimization for checking multiple values at once. AI\n; performance is based on how many \"nodes\" are evaluated, and boolean\n; operations like \"||\" are actually trinary functions, and thus surprisingly\n; expensive. The concat with [] is necessary to avoid matching when\n; turbo.state is empty, which happens on startup.\n; In most places, readability matters more, but here in the hottest loop of\n; turbo, every bit counts.\n\nstop(if(contains(\"[running][stopping]\", \"[\" . turbo.state . \"]\") || contains(turbo.state, \"idle\") && turbo.register > 0, \"TE2.2:turbo\", \"TE2.2:active\"))\nexecute(\"TE2.2:active\")\n"],["turbo_active","\n:name TE2.2:active\n\n; This script combined with turbo forms the core of turbo exec v2.\n; To understand how it works, see turbo.tpt2.\n\nexecute(\"TE2.2:turbo\")\n"],["turbo_counting","\n:name TE2.2:counting\n\n; This script counts the number of elapsed cycles since its execution.\n; This is used to halt turbo if it runs for too long.\n\n:global int turbo.cycles\n\nturbo.cycles = 0\nturbo.cycles += 1\n; Since scripts aren't removed from the script list as long as turbo is\n; running, their last instructions are instead run every cycle. This allows\n; repeating the same instruction each cycle.\n"],["turbo_start","\n:name turbo start\n\n; This script is a compatibility script for supporting TE2.1 scripts.\n; It performs the same functions as TE2.2:start, but with a different\n; script name.\n\n\n; This variable is used to track how many scripts are using turbo exec.\n; It's incremented each time `turbo start` is called, and decremented\n; every time `turbo stop` is called. When it reaches 0, turbo is stopped\n; and waits for the next script to register.\n:global int turbo.register\n\n; This variable is used to recieve state information from `<turbo> register`.\n:global string turbo.state\n\nturbo.register += 1 ; Increment the registry counter\n\n; This should guarantee turbo exec is up and is gonna keep running until\n; the next call to `turbo stop` (assuming no script interferes or causes\n; undefined behavior).\n; For instance, if `turbo start` is called shortly before cycles.max is\n; reached (due to another script using turbo), without this check it would\n; return just as turbo is stopping.\n; `goto` is being used here to stay consistent with `turbo stop`.\nwait:\ngoto(if(contains(turbo.state, \"running\"), end, wait))\n\n; Finishing the script with a noop is important, else the script will get\n; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\n"],["turbo_stop","\n:name turbo stop\n\n; This script is a compatibility script for supporting TE2.1 scripts.\n; It performs the same functions as TE2.2:stop, but with a different\n; script name.\n\n\n; This variable is used to track how many scripts are using turbo exec.\n; It's incremented each time `turbo start` is called, and decremented\n; everytime `turbo stop` is called. When it reaches 0, turbo is stopped\n; and waits for the next script to register.\n:global int turbo.register\n\n; This variable is used to recieve state information from `<turbo> register`.\n:global string turbo.state\n\n; Decrement the registry counter. There intentionally isn't a check for\n; negative, because if the calls are unbalanced that behavior should be\n; exposed quickly so it can be found and fixed.\nturbo.register -= 1\n\n; `turbo.state` first goes through the state \"stopping\", which happens 1 cycle\n; early. By exiting one cycle early, the caller script has a 1 cycle buffer to\n; call `turbo start` again to preserve frame continuity, but since the frame\n; skip is already planned at that point, even if the caller calls `turbo start`\n; right after this exits, the frame will be skipped correctly. This allows more\n; versatility in the caller's syntax and can save some crucial lines.\n; It is important to use `goto` here instead of `waituntil`, otherwise the extra\n; cycle would be consumed by waiting for the extra noop instruction at the end.\nwait:\ngoto(if(contains(turbo.state, \"running\"), wait, end))\n\n; Finishing the script with a noop is important, else the script will get\n; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\n"]]}}
```
