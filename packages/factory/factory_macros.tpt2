; Infrastructure for producing all the constants in the factory package.
; Since this is :imported, it can't produce any instructions.

; Produces the name of the queue variable for the given tier and item.
#queue_str "cq"
#queue(tier, item) -1 + 10 * ({item}) + {tier}

; Raw access to the queue. Not preferred, but better than using "queue"
; directly. Use for low-level optimization.
#get_raw(raw_item) global.double.get({queue_str} . (100 + {raw_item}))
#set_raw(raw_item, value) global.double.set({queue_str} . (100 + {raw_item}), {value})

; Helper macros for operating on the craft_queue. These should be
; used instead of direct access whenever possible.
#get_queue(tier, item) {get_raw({queue({tier},{item})})}
#set_queue(tier, item, value) {set_raw({queue({tier},{item})},{value})}

; Add/subtract a value from the queue. Although it expands to the same thing,
; it saves a lot of boilerplate in the source and makes it easier to understand
; what's going on.
#add_queue(tier, item, value) {set_queue({tier},{item},{get_queue({tier},{item})} + {value})}
#subtract_queue(tier, item, value) {set_queue({tier},{item},{get_queue({tier},{item})} - ({value}))}

; Used with factory.composite_string to extract the name from the
; returned data.
#get_name sub(itemdata, 0, index(itemdata, " ", 0))

; These macros can only be called *after* factory.composite_string,
; i.e. later on in the script.
#items_count {lua(return factory.items_count)}
#tiers_char sub(itemdata, {lua(return factory.entry_size - 1)}, 1)

{lua(\
  factory = {};\
  factory.items = {};\
  factory.item_names = {};\
  factory.name_max_size = 0;\
  factory.game_name_sizes = {};\
  factory.game_name_sizes[false] = 0;\
  factory.game_name_sizes[true] = 0;\
\
  function factory.add_item(name, tiers, game_name, is_craft)\
    local item = {};\
    item.id = #factory.items + 1;\
    if item.id > 89 then\
      return "Too many items: Over the limit while adding " .. name;\
    end\
    item.name = name;\
    item.game_name = game_name;\
    item.tier = tiers;\
    item.is_craft = is_craft;\
    factory.items[item.id] = item;\
    factory.item_names[name] = item;\
    if #name > factory.name_max_size then\
      factory.name_max_size = #name;\
    end\
    if #game_name > factory.game_name_sizes[is_craft] then\
      factory.game_name_sizes[is_craft] = #game_name;\
    end\
    return ":const int " .. name .. " " .. #factory.items;\
  end\
\
  function factory.composite_string(var, filter)\
    local acc = {};\
    local size = 0;\
    local first = #factory.items;\
    local last = 0;\
    if filter == nil then\
      size = math.max(factory.game_name_sizes[false], factory.game_name_sizes[true]);\
    else\
      size = factory.game_name_sizes[filter];\
    end\
    size = size + 1;\
    local fmt = "%-" .. size .. "s%d";\
    size = size + 1;\
    acc[1] = 'sub("';\
    for i = 1, #factory.items do\
      local item = factory.items[i];\
      if filter == nil or item.is_craft == filter then\
        acc[#acc + 1] = string.format(fmt, item.game_name, item.tier - 1);\
        if i < first then first = i end\
        if i > last then last = i end\
      end\
    end\
    acc[#acc + 1] = '", ' .. size .. " * (" .. var .. "), " .. size .. ')';\
    factory.items_count = last - first + 1;\
    factory.entry_size = size;\
    return table.concat(acc);\
  end\
)}

; Define a new production item with name "name", craftable from tiers 1-"tiers".
; The string passed to produce() is "game_name".
; It will take the next available id, starting from 1.
#item(name, tiers, game_name) {lua(\
  return factory.add_item("{name}", {tiers}, {game_name}, false)\
)}

; Define a new production item with name "name", craftable from tiers 1-"tiers".
; The string passed to craft() is "game_name".
; It will take the next available id, starting from 1.
#make(name, tiers, game_name) {lua(\
  return factory.add_item("{name}", {tiers}, {game_name}, true)\
)}
